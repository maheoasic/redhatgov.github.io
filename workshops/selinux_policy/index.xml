<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SELinux Policy Workshop on Red Hat | Public Sector</title>
    <link>http://redhatgov.io/workshops/selinux_policy/</link>
    <description>Recent content in SELinux Policy Workshop on Red Hat | Public Sector</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://redhatgov.io/workshops/selinux_policy/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Exercise 1.0 - Running Ad hoc commands</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise1.0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise1.0/</guid>
      <description>Exercise Description For our first exercise, we are going to run some ad hoc commands to help you get a feel for how Red Hat Ansible Tower works. Ansible ad hoc commands enable you to perform repeatable tasks on remote nodes, without having to write a playbook. They are very useful when you simply need to do one or two tasks quickly and often, to many remote nodes.
 Set Up Dependencies: Define your inventory.</description>
    </item>
    
    <item>
      <title>Exercise 1.1 - Writing Your First Playbook</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise1.1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise1.1/</guid>
      <description>Exercise Description Now that you&amp;#8217;ve gotten a sense of how Red Hat Ansible Tower works, we are going to write our first Ansible playbook. The playbook is where you can take some of those ad hoc commands you just ran and put them into a repeatable set of plays and tasks.
 A playbook can have multiple plays and a play can have one or multiple tasks. The goal of a play is to map a group of hosts.</description>
    </item>
    
    <item>
      <title>Exercise 1.2 - Running Your Playbook</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise1.2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise1.2/</guid>
      <description>Section 1: Running the playbook We are now going to run your brand-new playbook, on your two web nodes. To do this, you are going to use the ansible-playbook command.
 Step 1: Run your playbook From your playbook directory ( ~/apache_basic ), run your playbook.
 ansible-playbook -i ../hosts install_apache.yml --private-key=~/.ssh/example-tower   However, before you run that command, lets take a few moments to understand the options.
   --private-key This option asks for the private ssh key to connect to the remote machine.</description>
    </item>
    
    <item>
      <title>Exercise 1.3 - Using Variables, Loops, and Handlers</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise1.3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise1.3/</guid>
      <description>Exercise Description In previous exercises, we showed you the basics of the Ansible core. In the next few exercises, we are going to teach some more advanced Ansible skills that will add flexibility and power to your playbooks.
 Ansible exists to make tasks simple and repeatable. We also know that not all systems are exactly alike and often require some slight customization to the way an Ansible playbook is run.</description>
    </item>
    
    <item>
      <title>Exercise 1.4 - Running the apache-basic-playbook</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise1.4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise1.4/</guid>
      <description>Congratulations! You just wrote a playbook that incorporates some key Ansible concepts that you use in most, if not all, of your future playbooks. Before you get too excited though, we should probably make sure it actually runs. So, let&amp;#8217;s do that now.
   Section 1: Running your new apache playbook Step 1: Create a host file Make sure you are in the correct directory and create a host file.</description>
    </item>
    
    <item>
      <title>Exercise 1.5 - Roles: Making your playbooks reusable</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise1.5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise1.5/</guid>
      <description>Exercise Description While it is possible to write a playbook in one file, as we&amp;#8217;ve done throughout this workshop, eventually youâ€™ll want to reuse files and start to organize things.
 The &#34;role&#34; feature in Ansible is the way we do this. When you create a role, you deconstruct your playbook into parts and those parts sit in a directory structure. &#34;Wha?? You mean that seemingly useless best practice you mentioned in exercise 1.</description>
    </item>
    
    <item>
      <title>Exercise 2.0 - Creating Custom SELinux Policy</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise2.0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise2.0/</guid>
      <description>Exercise Description In this exercise, we are going to download the code for the example application that we are going to write policy for, and build and install it onto our test system.
 Step 1: Change directories Create a src directory, in your home directory.
 cd ~ mkdir src cd src   Step 2: Check out the source code to the example application from GitHub Download the latest code release</description>
    </item>
    
    <item>
      <title>Exercise 2.1 - Generating a generic policy</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise2.1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise2.1/</guid>
      <description>Exercise Description In this exercise, we are going to automatically generate an SELinux policy framework, and learn to handle AVC messages that are generated by SELinux, when the application violates the policy.
 Step 1: Generate an initial generic SELinux policy Create a policy directory, and generate an initial policy. Use sepolicy generate to generate a policy for the app that we want to enable.
 cd ~/src mkdir policy cd policy sepolicy generate --init /usr/local/sbin/testapp  Note the last few lines in the output from sepolicy generate:</description>
    </item>
    
    <item>
      <title>Exercise 2.2 - Creating a Custom SELinux Application Policy</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise2.2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise2.2/</guid>
      <description>Exercise Description This exercise will walk you through the steps required to handle AVC messages that are generated by SELinux, when an application violates existing policy. We will modify the already-created generic policy, in order to allow the application to run correctly, when we switch the policy to enforcing mode.
 Step 1: Check for AVC denials Now that our app is up and running, we can check the system logs for AVC (access vector cache, where SELinux caches decisions to grant or deny access) denial messages.</description>
    </item>
    
    <item>
      <title>Exercise 2.3 - Creating Policy Rules for Network Access</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise2.3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise2.3/</guid>
      <description>Exercise Description In this exercise, we will continue the modification of the generic application polocy to allow network traffic to be generated by the test application. There are several rules that will be needed, to handle a variety of AVC denials.
   Section 1: HTTP Port Connectivity Step 1: Check for AVC denials Let&amp;#8217;s restart our app, to get an updated list of denials.
 sudo systemctl restart testapp  Let&amp;#8217;s start with one of the denials that will be present in the audit search results, related to connecting on TCP port 80:</description>
    </item>
    
    <item>
      <title>Exercise 2.4 - Finishing the Policy</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise2.4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise2.4/</guid>
      <description>Exercise Description In this final exercise, we will finish the testapp SELinux policy.
   Section 1: A Last Interface Step 1: Check for AVC denials Let&amp;#8217;s again restart our app, to get an updated list of denials.
 sudo systemctl restart testapp  We only have a few denials left, and you will see that they all (probably!) reference /etc/resolv.conf or to /etc/hosts.
 sudo ausearch -m AVC -ts recent | egrep &amp;#39;^type=AVC&amp;#39;  type=AVC msg=audit(1553195947.</description>
    </item>
    
    <item>
      <title>Exercise 3.0 - Using Ansible to Implement Security</title>
      <link>http://redhatgov.io/workshops/selinux_policy/exercise3.0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/exercise3.0/</guid>
      <description>Exercise Description In this exercise, we are going to use Red Hat Ansible Tower to run a DISA STIG evaluation of our environment.
   DISA STIG controls https://galaxy.ansible.com/redhatofficial/rhel7_disa_stig
   Step 1: Download role to Ansible roles directory In your wetty window (if you closed it, see the SETUP step, in your workbook), type the following:
 sudo ansible-galaxy install redhatofficial.rhel7_disa_stig -p /etc/ansible/roles   The image below illustrates that the role has been downloaded to your system-wide Ansible roles directory, /etc/ansible/roles:</description>
    </item>
    
    <item>
      <title>Setup</title>
      <link>http://redhatgov.io/workshops/selinux_policy/setup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/setup/</guid>
      <description>What you will learn: Wetty (Browser-based SSH) This lab provides a quick tour of the browser based SSH client &#39;Wetty&#39;. To help you get familiar with lab environment along with some key terminology we will use in subsequent lab content.
   Accessing Wetty Use this URL to access the Wetty node, just change the workshop name (if applicable). Ask your instructor for the workshop name.</description>
    </item>
    
    <item>
      <title>Wrapup</title>
      <link>http://redhatgov.io/workshops/selinux_policy/wrapup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://redhatgov.io/workshops/selinux_policy/wrapup/</guid>
      <description>That wraps up what we have planned for today. We hope you&amp;#8217;ve learned something valuable about Ansible and Red Hat Ansible Tower that you can apply in your daily role.
 What do you think? How can we help you understand Ansible Tower better?
 Before you leave, check out the Resources page that is part of this guide. There, you can find a ton of links that will further your Ansible education.</description>
    </item>
    
  </channel>
</rss>